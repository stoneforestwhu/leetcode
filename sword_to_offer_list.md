3:
  3_1: 找出数组中只出现一次的重复的数
  3_2: 不改变数组的情况下找出数组中重复的数
4: 在2维数组(已排序)中查找目标值
5: 替换字符串中的空格
6: 逆序打印链表
7: 给定二叉树的前序遍历序列和中序遍历序列，重建二叉树
8:
9:
10:
11: 旋转数组中的最小数
19: 正则表达式的匹配,匹配.和*
20: 判断一个字符串是不是数字,(正负性, 科学计数等等)
21: 调整数组中的数字,使得所有的奇数在偶数前面
22: 链表中倒数第k个节点
23: 链表中环的入口节点
24: 反转链表
  24_1: 递归的方法反转链表
25: 合并两个排序的链表
26: 输入两棵二叉树A和B,判断B是不是A的子结构
27: 判断一个二叉树是不是镜像的
28: 判断一个二叉树是不是对称的
29: 顺时针打印矩阵(主要是边界条件的判断,很繁琐,值得注意)
30: 包含min函数的栈
31: 栈的压入弹出序列(假设前提是入栈的所有数字均不相等,给定第一个序列表示栈的压入顺序,
请判断第二个序列是否为该栈的弹出序列)  设置辅助栈,略难,需重写
  32_1: 不分行从上到下打印二叉树(单队列)
  32_2: 分行从上到下打印二叉树(单队列+计数器)
  32_3: 之字形打印二叉树(双栈 + flag)
  32_4: 对二叉树增加一个指向右侧节点的指针  (极难,看代码就懂,但是写不下来,需要多重复几次)
33: 判断一个数组是不是某个二叉搜索树的后序遍历结果(二叉搜索树中比根节点大的数都在右子树中,比根节点小的数都在左子树中)
34: 二叉树中和为某一值的路径
35: 复杂链表的复制
36: 将二叉搜索树转换成一个链表
37: 实现函数来序列化和反序列化二叉树
38: 字符串的排列，实现函数打印一个字符串的所有字符串排列组合的情况
  38_1: 立方体顶点的值
  38_2: 八皇后问题
39: 数组中出现次数超过数组一半长度的数
40: 最小的k个数
41: 数据流中大小在中间的数
